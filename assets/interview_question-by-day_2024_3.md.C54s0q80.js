import{_ as s,o as i,c as a,U as n}from"./chunks/framework.BybONTeF.js";const c=JSON.parse('{"title":"每日一题","description":"","frontmatter":{"readingTime":false,"hidden":true},"headers":[],"relativePath":"interview/question-by-day/2024/3.md","filePath":"interview/question-by-day/2024/3.md","lastUpdated":1711094900000}'),l={name:"interview/question-by-day/2024/3.md"},h=n(`<h1 id="每日一题" tabindex="-1">每日一题 <a class="header-anchor" href="#每日一题" aria-label="Permalink to &quot;每日一题&quot;">​</a></h1><h2 id="_3-22" tabindex="-1">3-22 <a class="header-anchor" href="#_3-22" aria-label="Permalink to &quot;3-22&quot;">​</a></h2><h3 id="什么是动态代理" tabindex="-1">什么是动态代理？ <a class="header-anchor" href="#什么是动态代理" aria-label="Permalink to &quot;什么是动态代理？&quot;">​</a></h3><p>动态代理是指在运行时动态生成代理类，通过 Java 的反射机制动态生成代理类，然后在代理类中实现接口方法，实现对目标对象的代理访问。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//接口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserDao</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> save</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//接口实现类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserDaoImpl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserDao</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> save</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;保存数据方法&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> InvocationHandlerImpl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> InvocationHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 这其实业务实现类对象，用来调用具体的业务方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object target;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 通过构造函数传入目标对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> InvocationHandlerImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //动态代理实际运行的代理方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Method </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">method</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Throwable {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;调用开始处理&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //下面invoke()方法是以反射的方式来创建对象，第一个参数是要创建的对象，第二个是构成方法的参数，由第二个参数来决定创建对象使用哪个构造方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Object result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> method.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;调用结束处理&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//测试</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 被代理对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        UserDao userDaoImpl </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserDaoImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        InvocationHandlerImpl invocationHandlerImpl </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> InvocationHandlerImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userDaoImpl);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //类加载器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ClassLoader loader </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> userDaoImpl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Class&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;[] interfaces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> userDaoImpl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInterfaces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 主要装载器、一组接口及调用处理动态代理实例</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        UserDao newProxyInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (UserDao) Proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newProxyInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loader, interfaces, invocationHandlerImpl);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        newProxyInstance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">save</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_3-21" tabindex="-1">3-21 <a class="header-anchor" href="#_3-21" aria-label="Permalink to &quot;3-21&quot;">​</a></h2><h3 id="什么是静态代理" tabindex="-1">什么是静态代理？ <a class="header-anchor" href="#什么是静态代理" aria-label="Permalink to &quot;什么是静态代理？&quot;">​</a></h3><p>静态代理是指在编译时就已经确定代理的对象，通过在代码中显式定义一个代理类，代理类通过实现与目标对象相同的接口 然后在代理类中维护一个目标对象，通过构造方法或者其他方式传入目标对象，同时在代理类中实现接口方法，实现对目标对象的代理访问。</p><p>示例：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 接口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ISubject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 目标对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RealSubject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ISubject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;RealSubject request&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 代理对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProxySubject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ISubject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ISubject realSubject;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProxySubject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ISubject </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">realSubject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.realSubject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> realSubject;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ProxySubject before request&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        realSubject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ProxySubject after request&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 测试</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ISubject realSubject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RealSubject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ISubject proxySubject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProxySubject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(realSubject);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        proxySubject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_3-20" tabindex="-1">3-20 <a class="header-anchor" href="#_3-20" aria-label="Permalink to &quot;3-20&quot;">​</a></h2><h3 id="代理模式的分类" tabindex="-1">代理模式的分类？ <a class="header-anchor" href="#代理模式的分类" aria-label="Permalink to &quot;代理模式的分类？&quot;">​</a></h3><p><strong>静态代理：</strong> 简单代理模式，是动态代理的理论基础。常见使用在代理模式 <strong>jdk动态代理：</strong> 使用反射完成代理。需要有顶层接口才能使用，常见是mybatis的mapper文件是代理。 <strong>cglib：</strong> 第三方动态代理，使用反射完成代理，可以直接代理类（jdk动态代理不行），使用字节码技术，不能对 final类进行继承。</p><h2 id="_3-19" tabindex="-1">3-19 <a class="header-anchor" href="#_3-19" aria-label="Permalink to &quot;3-19&quot;">​</a></h2><h3 id="什么是代理模式" tabindex="-1">什么是代理模式？ <a class="header-anchor" href="#什么是代理模式" aria-label="Permalink to &quot;什么是代理模式？&quot;">​</a></h3><p>通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。(也就是AOP的微实现)</p><p>代理在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能，这也和 Spring 的（面向切面编程）很相似</p><h2 id="_3-18" tabindex="-1">3-18 <a class="header-anchor" href="#_3-18" aria-label="Permalink to &quot;3-18&quot;">​</a></h2><h3 id="什么是工厂模式" tabindex="-1">什么是工厂模式？ <a class="header-anchor" href="#什么是工厂模式" aria-label="Permalink to &quot;什么是工厂模式？&quot;">​</a></h3><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 工厂模式提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 实现了创建者和调用者分离，工厂模式分为简单工厂、工厂方法、抽象工厂模式。</p><h2 id="_3-17" tabindex="-1">3-17 <a class="header-anchor" href="#_3-17" aria-label="Permalink to &quot;3-17&quot;">​</a></h2><h3 id="单例模式有哪些创建方式" tabindex="-1">单例模式有哪些创建方式？ <a class="header-anchor" href="#单例模式有哪些创建方式" aria-label="Permalink to &quot;单例模式有哪些创建方式？&quot;">​</a></h3><ul><li><strong>饿汉式:</strong> 类初始化时,会立即加载该对象，线程天生安全,调用效率高。</li><li><strong>懒汉式:</strong> 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。</li><li><strong>静态内部方式:</strong> 结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</li><li><strong>枚举单例:</strong> 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。</li></ul><h2 id="_3-16" tabindex="-1">3-16 <a class="header-anchor" href="#_3-16" aria-label="Permalink to &quot;3-16&quot;">​</a></h2><h3 id="什么是合成复用原则" tabindex="-1">什么是合成复用原则？ <a class="header-anchor" href="#什么是合成复用原则" aria-label="Permalink to &quot;什么是合成复用原则？&quot;">​</a></h3><ul><li><strong>原则思想：</strong> 它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</li><li><strong>描述：</strong> 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</li><li><strong>优点：</strong> 它维持了类的封装性，新旧类之间的耦合度低，复用的灵活性高。</li></ul><h2 id="_3-15" tabindex="-1">3-15 <a class="header-anchor" href="#_3-15" aria-label="Permalink to &quot;3-15&quot;">​</a></h2><h3 id="什么是迪米特法则" tabindex="-1">什么是迪米特法则？ <a class="header-anchor" href="#什么是迪米特法则" aria-label="Permalink to &quot;什么是迪米特法则？&quot;">​</a></h3><blockquote><p>迪米特法则又称最少知识原则。</p></blockquote><ul><li><strong>原则思想：</strong> 一个对象应该对其他对象保持最少的了解。</li><li><strong>描述：</strong> 一个对象应该对其他对象保持最少的了解，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都应该将逻辑封装在类的内部，对外提供的方法越少越好。</li><li><strong>优点：</strong> 迪米特法则可以减少类间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性。</li></ul><h2 id="_3-14" tabindex="-1">3-14 <a class="header-anchor" href="#_3-14" aria-label="Permalink to &quot;3-14&quot;">​</a></h2><h3 id="什么是接口隔离原则" tabindex="-1">什么是接口隔离原则？ <a class="header-anchor" href="#什么是接口隔离原则" aria-label="Permalink to &quot;什么是接口隔离原则？&quot;">​</a></h3><ul><li><strong>原则思想：</strong> 使用多个专门的接口，而不使用单一的总接口。</li><li><strong>描述：</strong> 接口隔离原则是指客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</li><li><strong>优点：</strong> 接口隔离原则可以减少类间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性。</li></ul><h2 id="_3-13" tabindex="-1">3-13 <a class="header-anchor" href="#_3-13" aria-label="Permalink to &quot;3-13&quot;">​</a></h2><h3 id="什么是依赖倒置原则" tabindex="-1">什么是依赖倒置原则？ <a class="header-anchor" href="#什么是依赖倒置原则" aria-label="Permalink to &quot;什么是依赖倒置原则？&quot;">​</a></h3><ul><li><strong>原则思想：</strong> 面向接口编程，依赖于抽象而不依赖于具体。</li><li><strong>描述：</strong> 依赖倒置原则是指在设计软件结构时，高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</li><li><strong>优点：</strong> 依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性。</li></ul><h2 id="_3-12" tabindex="-1">3-12 <a class="header-anchor" href="#_3-12" aria-label="Permalink to &quot;3-12&quot;">​</a></h2><h3 id="什么是里氏替换原则" tabindex="-1">什么是里氏替换原则？ <a class="header-anchor" href="#什么是里氏替换原则" aria-label="Permalink to &quot;什么是里氏替换原则？&quot;">​</a></h3><ul><li><strong>原则思想：</strong> 使用的基类可以在任何地方使用继承的子类，完美的替换基类。</li><li><strong>描述：</strong> 子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。</li><li><strong>优点：</strong> 增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。</li></ul><h2 id="_3-11" tabindex="-1">3-11 <a class="header-anchor" href="#_3-11" aria-label="Permalink to &quot;3-11&quot;">​</a></h2><h3 id="什么是开放封闭原则" tabindex="-1">什么是开放封闭原则？ <a class="header-anchor" href="#什么是开放封闭原则" aria-label="Permalink to &quot;什么是开放封闭原则？&quot;">​</a></h3><ul><li><strong>思想：</strong> 尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</li><li><strong>描述：</strong> 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li><li><strong>优点：</strong> 单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。</li></ul><h2 id="_3-10" tabindex="-1">3-10 <a class="header-anchor" href="#_3-10" aria-label="Permalink to &quot;3-10&quot;">​</a></h2><h3 id="设计模式的六大原则" tabindex="-1">设计模式的六大原则？ <a class="header-anchor" href="#设计模式的六大原则" aria-label="Permalink to &quot;设计模式的六大原则？&quot;">​</a></h3><ol><li>开闭原则：对扩展开放，对修改关闭。</li><li>里氏替换原则：子类可以替换父类。</li><li>依赖倒置原则：面向接口编程，依赖于抽象而不依赖于具体。</li><li>接口隔离原则：使用多个专门的接口，而不使用单一的总接口。</li><li>迪米特法则：一个对象应该对其他对象保持最少的了解。</li><li>合成复用原则：尽量使用合成/聚合的方式，而不是使用继承。</li></ol><h2 id="_3-9" tabindex="-1">3-9 <a class="header-anchor" href="#_3-9" aria-label="Permalink to &quot;3-9&quot;">​</a></h2><h3 id="设计模式有哪些" tabindex="-1">设计模式有哪些？ <a class="header-anchor" href="#设计模式有哪些" aria-label="Permalink to &quot;设计模式有哪些？&quot;">​</a></h3><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h2 id="_3-8" tabindex="-1">3-8 <a class="header-anchor" href="#_3-8" aria-label="Permalink to &quot;3-8&quot;">​</a></h2><h3 id="设计模式有哪些类别" tabindex="-1">设计模式有哪些类别？ <a class="header-anchor" href="#设计模式有哪些类别" aria-label="Permalink to &quot;设计模式有哪些类别？&quot;">​</a></h3><p>设计模式有 23 种，分为创建型模式、结构型模式和行为型模式。</p><h2 id="_3-7" tabindex="-1">3-7 <a class="header-anchor" href="#_3-7" aria-label="Permalink to &quot;3-7&quot;">​</a></h2><h3 id="什么是设计模式" tabindex="-1">什么是设计模式? <a class="header-anchor" href="#什么是设计模式" aria-label="Permalink to &quot;什么是设计模式?&quot;">​</a></h3><p>设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><p>使用设计模式是为了可重用代码、让代码更容易被理解、保证代码的可靠性、程序的可维护性。</p><h2 id="_3-6" tabindex="-1">3-6 <a class="header-anchor" href="#_3-6" aria-label="Permalink to &quot;3-6&quot;">​</a></h2><h3 id="mybatis-plus-有哪些主要的-api" tabindex="-1">Mybatis Plus 有哪些主要的 API？ <a class="header-anchor" href="#mybatis-plus-有哪些主要的-api" aria-label="Permalink to &quot;Mybatis Plus 有哪些主要的 API？&quot;">​</a></h3><ul><li>Wrapper API：条件构造器，用于构造查询条件。包括 QueryWrapper、UpdateWrapper、LambdaQueryWrapper、LambdaUpdateWrapper。</li><li>Service API：Service 接口，用于定义 Service 层的接口。</li><li>Page API：分页插件，用于分页查询。</li><li>Entity API：实体类接口，用于定义实体类。</li></ul><h2 id="_3-5" tabindex="-1">3-5 <a class="header-anchor" href="#_3-5" aria-label="Permalink to &quot;3-5&quot;">​</a></h2><h3 id="什么是-mybatis-plus" tabindex="-1">什么是 Mybatis Plus？ <a class="header-anchor" href="#什么是-mybatis-plus" aria-label="Permalink to &quot;什么是 Mybatis Plus？&quot;">​</a></h3><p>Mybatis Plus 是 Mybatis 的增强工具包，它是在 Mybatis 的基础上进行了扩展，简化了 Mybatis 的开发，提供了很多实用的功能， 比如分页、逻辑删除、自动填充、性能分析等。</p><h2 id="_3-4" tabindex="-1">3-4 <a class="header-anchor" href="#_3-4" aria-label="Permalink to &quot;3-4&quot;">​</a></h2><h3 id="mybatis-的接口绑定和实现方式" tabindex="-1">MyBatis 的接口绑定和实现方式 <a class="header-anchor" href="#mybatis-的接口绑定和实现方式" aria-label="Permalink to &quot;MyBatis 的接口绑定和实现方式&quot;">​</a></h3><p>接口绑定是指在 Mybatis 中任意定义接口，然后把接口中的方法和 SQL 语句绑定，我们直接调用接口方法就可以， 这样比原来 SqlSession 提供的方法更加直观和简洁，也可以更加灵活。</p><p>实现方式如下：</p><ul><li>注解绑定，就是在接口的方法上加<code> @Select</code>，<code>@Update</code> 等注解。</li><li>XML 绑定，就是在 XML 文件中定义接口的方法和 SQL 语句的映射关系。</li></ul><h2 id="_3-3" tabindex="-1">3-3 <a class="header-anchor" href="#_3-3" aria-label="Permalink to &quot;3-3&quot;">​</a></h2><h3 id="请描述-mybatis-的动态-sql。" tabindex="-1">请描述 Mybatis 的动态 SQL。 <a class="header-anchor" href="#请描述-mybatis-的动态-sql。" aria-label="Permalink to &quot;请描述 Mybatis 的动态 SQL。&quot;">​</a></h3><p>Mybatis 的动态 SQL 是通过<code>标签来实现的，</code>标签可以根据条件来动态拼接 SQL 语句。</p><ul><li>if 标签：判断条件是否成立，成立则拼接 SQL 语句。</li><li>choose 标签：类似于 Java 中的 switch 语句，根据条件来选择拼接 SQL 语句。</li><li>when 标签：配合 choose 标签使用，表示条件成立时拼接 SQL 语句。</li><li>otherwise 标签：配合 choose 标签使用，表示条件不成立时拼接 SQL 语句。</li><li>trim 标签：去除 SQL 语句中的多余字符。</li><li>where 标签：配合 trim 标签使用，去除 SQL 语句中的多余字符。</li><li>set 标签：配合 trim 标签使用，去除 SQL 语句中的多余字符。</li><li>foreach 标签：遍历集合，拼接 SQL 语句。</li></ul><h2 id="_3-2" tabindex="-1">3-2 <a class="header-anchor" href="#_3-2" aria-label="Permalink to &quot;3-2&quot;">​</a></h2><h3 id="请描述-mybatis-的缓存机制。" tabindex="-1">请描述 Mybatis 的缓存机制。 <a class="header-anchor" href="#请描述-mybatis-的缓存机制。" aria-label="Permalink to &quot;请描述 Mybatis 的缓存机制。&quot;">​</a></h3><p>Mybatis 的缓存机制分为一级缓存和二级缓存。</p><p><strong>一级缓存</strong> 是 SqlSession 级别的缓存，当调用 SqlSession 的查询方法时，Mybatis 会将查询结果放入到缓存中， 当再次查询相同的数据时，直接从缓存中获取，不会再次查询数据库。</p><p><strong>二级缓存</strong> 是 Mapper 级别的缓存，多个 SqlSession 共享同一个 Mapper 的二级缓存，当调用 SqlSession 的查询方法时， Mybatis 会将查询结果放入到缓存中，当再次查询相同的数据时，直接从缓存中获取，不会再次查询数据库。</p><h2 id="_3-1" tabindex="-1">3-1 <a class="header-anchor" href="#_3-1" aria-label="Permalink to &quot;3-1&quot;">​</a></h2><h3 id="mybatis-实现一对一有几种方式" tabindex="-1">MyBatis 实现一对一有几种方式? <a class="header-anchor" href="#mybatis-实现一对一有几种方式" aria-label="Permalink to &quot;MyBatis 实现一对一有几种方式?&quot;">​</a></h3><p>有联合查询和嵌套查询。</p><p><strong>联合查询</strong> 是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；</p><p><strong>嵌套查询</strong> 是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。</p>`,82),t=[h];function e(p,k,r,d,E,o){return i(),a("div",null,t)}const y=s(l,[["render",e]]);export{c as __pageData,y as default};
