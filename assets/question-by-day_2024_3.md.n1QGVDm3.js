import{_ as a,o as e,c as t,U as i}from"./chunks/framework.c8sqUf1u.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{"readingTime":false,"hidden":true},"headers":[],"relativePath":"question-by-day/2024/3.md","filePath":"question-by-day/2024/3.md","lastUpdated":1709521316000}'),s={name:"question-by-day/2024/3.md"},o=i('<h2 id="_3-3" tabindex="-1">3-3 <a class="header-anchor" href="#_3-3" aria-label="Permalink to &quot;3-3&quot;">​</a></h2><h3 id="请描述-mybatis-的动态-sql。" tabindex="-1">请描述 Mybatis 的动态 SQL。 <a class="header-anchor" href="#请描述-mybatis-的动态-sql。" aria-label="Permalink to &quot;请描述 Mybatis 的动态 SQL。&quot;">​</a></h3><p>Mybatis 的动态 SQL 是通过<code>标签来实现的，</code>标签可以根据条件来动态拼接 SQL 语句。</p><ul><li>if 标签：判断条件是否成立，成立则拼接 SQL 语句。</li><li>choose 标签：类似于 Java 中的 switch 语句，根据条件来选择拼接 SQL 语句。</li><li>when 标签：配合 choose 标签使用，表示条件成立时拼接 SQL 语句。</li><li>otherwise 标签：配合 choose 标签使用，表示条件不成立时拼接 SQL 语句。</li><li>trim 标签：去除 SQL 语句中的多余字符。</li><li>where 标签：配合 trim 标签使用，去除 SQL 语句中的多余字符。</li><li>set 标签：配合 trim 标签使用，去除 SQL 语句中的多余字符。</li><li>foreach 标签：遍历集合，拼接 SQL 语句。</li></ul><h2 id="_3-2" tabindex="-1">3-2 <a class="header-anchor" href="#_3-2" aria-label="Permalink to &quot;3-2&quot;">​</a></h2><h3 id="请描述-mybatis-的缓存机制。" tabindex="-1">请描述 Mybatis 的缓存机制。 <a class="header-anchor" href="#请描述-mybatis-的缓存机制。" aria-label="Permalink to &quot;请描述 Mybatis 的缓存机制。&quot;">​</a></h3><p>Mybatis 的缓存机制分为一级缓存和二级缓存。</p><p><strong>一级缓存</strong> 是 SqlSession 级别的缓存，当调用 SqlSession 的查询方法时，Mybatis 会将查询结果放入到缓存中， 当再次查询相同的数据时，直接从缓存中获取，不会再次查询数据库。</p><p><strong>二级缓存</strong> 是 Mapper 级别的缓存，多个 SqlSession 共享同一个 Mapper 的二级缓存，当调用 SqlSession 的查询方法时， Mybatis 会将查询结果放入到缓存中，当再次查询相同的数据时，直接从缓存中获取，不会再次查询数据库。</p><h2 id="_3-1" tabindex="-1">3-1 <a class="header-anchor" href="#_3-1" aria-label="Permalink to &quot;3-1&quot;">​</a></h2><h3 id="mybatis-实现一对一有几种方式" tabindex="-1">MyBatis 实现一对一有几种方式? <a class="header-anchor" href="#mybatis-实现一对一有几种方式" aria-label="Permalink to &quot;MyBatis 实现一对一有几种方式?&quot;">​</a></h3><p>有联合查询和嵌套查询。</p><p><strong>联合查询</strong> 是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；</p><p><strong>嵌套查询</strong> 是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。</p>',14),r=[o];function l(n,h,d,c,_,p){return e(),t("div",null,r)}const S=a(s,[["render",l]]);export{m as __pageData,S as default};
