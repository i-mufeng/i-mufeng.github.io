import{_ as a,o as e,c as i,U as t}from"./chunks/framework.AM0-35oE.js";const p=JSON.parse('{"title":"每日一题","description":"","frontmatter":{"readingTime":false,"hidden":true},"headers":[],"relativePath":"interview/question-by-day/2024/3.md","filePath":"interview/question-by-day/2024/3.md","lastUpdated":1710839104000}'),r={name:"interview/question-by-day/2024/3.md"},l=t('<h1 id="每日一题" tabindex="-1">每日一题 <a class="header-anchor" href="#每日一题" aria-label="Permalink to &quot;每日一题&quot;">​</a></h1><h2 id="_3-19" tabindex="-1">3-19 <a class="header-anchor" href="#_3-19" aria-label="Permalink to &quot;3-19&quot;">​</a></h2><h3 id="什么是代理模式" tabindex="-1">什么是代理模式？ <a class="header-anchor" href="#什么是代理模式" aria-label="Permalink to &quot;什么是代理模式？&quot;">​</a></h3><p>通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。(也就是AOP的微实现)</p><p>代理在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能，这也和 Spring 的（面向切面编程）很相似</p><h2 id="_3-18" tabindex="-1">3-18 <a class="header-anchor" href="#_3-18" aria-label="Permalink to &quot;3-18&quot;">​</a></h2><h3 id="什么是工厂模式" tabindex="-1">什么是工厂模式？ <a class="header-anchor" href="#什么是工厂模式" aria-label="Permalink to &quot;什么是工厂模式？&quot;">​</a></h3><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 工厂模式提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 实现了创建者和调用者分离，工厂模式分为简单工厂、工厂方法、抽象工厂模式。</p><h2 id="_3-17" tabindex="-1">3-17 <a class="header-anchor" href="#_3-17" aria-label="Permalink to &quot;3-17&quot;">​</a></h2><h3 id="单例模式有哪些创建方式" tabindex="-1">单例模式有哪些创建方式？ <a class="header-anchor" href="#单例模式有哪些创建方式" aria-label="Permalink to &quot;单例模式有哪些创建方式？&quot;">​</a></h3><ul><li><strong>饿汉式:</strong> 类初始化时,会立即加载该对象，线程天生安全,调用效率高。</li><li><strong>懒汉式:</strong> 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。</li><li><strong>静态内部方式:</strong> 结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</li><li><strong>枚举单例:</strong> 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。</li></ul><h2 id="_3-16" tabindex="-1">3-16 <a class="header-anchor" href="#_3-16" aria-label="Permalink to &quot;3-16&quot;">​</a></h2><h3 id="什么是合成复用原则" tabindex="-1">什么是合成复用原则？ <a class="header-anchor" href="#什么是合成复用原则" aria-label="Permalink to &quot;什么是合成复用原则？&quot;">​</a></h3><ul><li><strong>原则思想：</strong> 它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</li><li><strong>描述：</strong> 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</li><li><strong>优点：</strong> 它维持了类的封装性，新旧类之间的耦合度低，复用的灵活性高。</li></ul><h2 id="_3-15" tabindex="-1">3-15 <a class="header-anchor" href="#_3-15" aria-label="Permalink to &quot;3-15&quot;">​</a></h2><h3 id="什么是迪米特法则" tabindex="-1">什么是迪米特法则？ <a class="header-anchor" href="#什么是迪米特法则" aria-label="Permalink to &quot;什么是迪米特法则？&quot;">​</a></h3><blockquote><p>迪米特法则又称最少知识原则。</p></blockquote><ul><li><strong>原则思想：</strong> 一个对象应该对其他对象保持最少的了解。</li><li><strong>描述：</strong> 一个对象应该对其他对象保持最少的了解，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都应该将逻辑封装在类的内部，对外提供的方法越少越好。</li><li><strong>优点：</strong> 迪米特法则可以减少类间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性。</li></ul><h2 id="_3-14" tabindex="-1">3-14 <a class="header-anchor" href="#_3-14" aria-label="Permalink to &quot;3-14&quot;">​</a></h2><h3 id="什么是接口隔离原则" tabindex="-1">什么是接口隔离原则？ <a class="header-anchor" href="#什么是接口隔离原则" aria-label="Permalink to &quot;什么是接口隔离原则？&quot;">​</a></h3><ul><li><strong>原则思想：</strong> 使用多个专门的接口，而不使用单一的总接口。</li><li><strong>描述：</strong> 接口隔离原则是指客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</li><li><strong>优点：</strong> 接口隔离原则可以减少类间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性。</li></ul><h2 id="_3-13" tabindex="-1">3-13 <a class="header-anchor" href="#_3-13" aria-label="Permalink to &quot;3-13&quot;">​</a></h2><h3 id="什么是依赖倒置原则" tabindex="-1">什么是依赖倒置原则？ <a class="header-anchor" href="#什么是依赖倒置原则" aria-label="Permalink to &quot;什么是依赖倒置原则？&quot;">​</a></h3><ul><li><strong>原则思想：</strong> 面向接口编程，依赖于抽象而不依赖于具体。</li><li><strong>描述：</strong> 依赖倒置原则是指在设计软件结构时，高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</li><li><strong>优点：</strong> 依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性。</li></ul><h2 id="_3-12" tabindex="-1">3-12 <a class="header-anchor" href="#_3-12" aria-label="Permalink to &quot;3-12&quot;">​</a></h2><h3 id="什么是里氏替换原则" tabindex="-1">什么是里氏替换原则？ <a class="header-anchor" href="#什么是里氏替换原则" aria-label="Permalink to &quot;什么是里氏替换原则？&quot;">​</a></h3><ul><li><strong>原则思想：</strong> 使用的基类可以在任何地方使用继承的子类，完美的替换基类。</li><li><strong>描述：</strong> 子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。</li><li><strong>优点：</strong> 增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。</li></ul><h2 id="_3-11" tabindex="-1">3-11 <a class="header-anchor" href="#_3-11" aria-label="Permalink to &quot;3-11&quot;">​</a></h2><h3 id="什么是开放封闭原则" tabindex="-1">什么是开放封闭原则？ <a class="header-anchor" href="#什么是开放封闭原则" aria-label="Permalink to &quot;什么是开放封闭原则？&quot;">​</a></h3><ul><li><strong>思想：</strong> 尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</li><li><strong>描述：</strong> 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li><li><strong>优点：</strong> 单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。</li></ul><h2 id="_3-10" tabindex="-1">3-10 <a class="header-anchor" href="#_3-10" aria-label="Permalink to &quot;3-10&quot;">​</a></h2><h3 id="设计模式的六大原则" tabindex="-1">设计模式的六大原则？ <a class="header-anchor" href="#设计模式的六大原则" aria-label="Permalink to &quot;设计模式的六大原则？&quot;">​</a></h3><ol><li>开闭原则：对扩展开放，对修改关闭。</li><li>里氏替换原则：子类可以替换父类。</li><li>依赖倒置原则：面向接口编程，依赖于抽象而不依赖于具体。</li><li>接口隔离原则：使用多个专门的接口，而不使用单一的总接口。</li><li>迪米特法则：一个对象应该对其他对象保持最少的了解。</li><li>合成复用原则：尽量使用合成/聚合的方式，而不是使用继承。</li></ol><h2 id="_3-9" tabindex="-1">3-9 <a class="header-anchor" href="#_3-9" aria-label="Permalink to &quot;3-9&quot;">​</a></h2><h3 id="设计模式有哪些" tabindex="-1">设计模式有哪些？ <a class="header-anchor" href="#设计模式有哪些" aria-label="Permalink to &quot;设计模式有哪些？&quot;">​</a></h3><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h2 id="_3-8" tabindex="-1">3-8 <a class="header-anchor" href="#_3-8" aria-label="Permalink to &quot;3-8&quot;">​</a></h2><h3 id="设计模式有哪些类别" tabindex="-1">设计模式有哪些类别？ <a class="header-anchor" href="#设计模式有哪些类别" aria-label="Permalink to &quot;设计模式有哪些类别？&quot;">​</a></h3><p>设计模式有 23 种，分为创建型模式、结构型模式和行为型模式。</p><h2 id="_3-7" tabindex="-1">3-7 <a class="header-anchor" href="#_3-7" aria-label="Permalink to &quot;3-7&quot;">​</a></h2><h3 id="什么是设计模式" tabindex="-1">什么是设计模式? <a class="header-anchor" href="#什么是设计模式" aria-label="Permalink to &quot;什么是设计模式?&quot;">​</a></h3><p>设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><p>使用设计模式是为了可重用代码、让代码更容易被理解、保证代码的可靠性、程序的可维护性。</p><h2 id="_3-6" tabindex="-1">3-6 <a class="header-anchor" href="#_3-6" aria-label="Permalink to &quot;3-6&quot;">​</a></h2><h3 id="mybatis-plus-有哪些主要的-api" tabindex="-1">Mybatis Plus 有哪些主要的 API？ <a class="header-anchor" href="#mybatis-plus-有哪些主要的-api" aria-label="Permalink to &quot;Mybatis Plus 有哪些主要的 API？&quot;">​</a></h3><ul><li>Wrapper API：条件构造器，用于构造查询条件。包括 QueryWrapper、UpdateWrapper、LambdaQueryWrapper、LambdaUpdateWrapper。</li><li>Service API：Service 接口，用于定义 Service 层的接口。</li><li>Page API：分页插件，用于分页查询。</li><li>Entity API：实体类接口，用于定义实体类。</li></ul><h2 id="_3-5" tabindex="-1">3-5 <a class="header-anchor" href="#_3-5" aria-label="Permalink to &quot;3-5&quot;">​</a></h2><h3 id="什么是-mybatis-plus" tabindex="-1">什么是 Mybatis Plus？ <a class="header-anchor" href="#什么是-mybatis-plus" aria-label="Permalink to &quot;什么是 Mybatis Plus？&quot;">​</a></h3><p>Mybatis Plus 是 Mybatis 的增强工具包，它是在 Mybatis 的基础上进行了扩展，简化了 Mybatis 的开发，提供了很多实用的功能， 比如分页、逻辑删除、自动填充、性能分析等。</p><h2 id="_3-4" tabindex="-1">3-4 <a class="header-anchor" href="#_3-4" aria-label="Permalink to &quot;3-4&quot;">​</a></h2><h3 id="mybatis-的接口绑定和实现方式" tabindex="-1">MyBatis 的接口绑定和实现方式 <a class="header-anchor" href="#mybatis-的接口绑定和实现方式" aria-label="Permalink to &quot;MyBatis 的接口绑定和实现方式&quot;">​</a></h3><p>接口绑定是指在 Mybatis 中任意定义接口，然后把接口中的方法和 SQL 语句绑定，我们直接调用接口方法就可以， 这样比原来 SqlSession 提供的方法更加直观和简洁，也可以更加灵活。</p><p>实现方式如下：</p><ul><li>注解绑定，就是在接口的方法上加<code> @Select</code>，<code>@Update</code> 等注解。</li><li>XML 绑定，就是在 XML 文件中定义接口的方法和 SQL 语句的映射关系。</li></ul><h2 id="_3-3" tabindex="-1">3-3 <a class="header-anchor" href="#_3-3" aria-label="Permalink to &quot;3-3&quot;">​</a></h2><h3 id="请描述-mybatis-的动态-sql。" tabindex="-1">请描述 Mybatis 的动态 SQL。 <a class="header-anchor" href="#请描述-mybatis-的动态-sql。" aria-label="Permalink to &quot;请描述 Mybatis 的动态 SQL。&quot;">​</a></h3><p>Mybatis 的动态 SQL 是通过<code>标签来实现的，</code>标签可以根据条件来动态拼接 SQL 语句。</p><ul><li>if 标签：判断条件是否成立，成立则拼接 SQL 语句。</li><li>choose 标签：类似于 Java 中的 switch 语句，根据条件来选择拼接 SQL 语句。</li><li>when 标签：配合 choose 标签使用，表示条件成立时拼接 SQL 语句。</li><li>otherwise 标签：配合 choose 标签使用，表示条件不成立时拼接 SQL 语句。</li><li>trim 标签：去除 SQL 语句中的多余字符。</li><li>where 标签：配合 trim 标签使用，去除 SQL 语句中的多余字符。</li><li>set 标签：配合 trim 标签使用，去除 SQL 语句中的多余字符。</li><li>foreach 标签：遍历集合，拼接 SQL 语句。</li></ul><h2 id="_3-2" tabindex="-1">3-2 <a class="header-anchor" href="#_3-2" aria-label="Permalink to &quot;3-2&quot;">​</a></h2><h3 id="请描述-mybatis-的缓存机制。" tabindex="-1">请描述 Mybatis 的缓存机制。 <a class="header-anchor" href="#请描述-mybatis-的缓存机制。" aria-label="Permalink to &quot;请描述 Mybatis 的缓存机制。&quot;">​</a></h3><p>Mybatis 的缓存机制分为一级缓存和二级缓存。</p><p><strong>一级缓存</strong> 是 SqlSession 级别的缓存，当调用 SqlSession 的查询方法时，Mybatis 会将查询结果放入到缓存中， 当再次查询相同的数据时，直接从缓存中获取，不会再次查询数据库。</p><p><strong>二级缓存</strong> 是 Mapper 级别的缓存，多个 SqlSession 共享同一个 Mapper 的二级缓存，当调用 SqlSession 的查询方法时， Mybatis 会将查询结果放入到缓存中，当再次查询相同的数据时，直接从缓存中获取，不会再次查询数据库。</p><h2 id="_3-1" tabindex="-1">3-1 <a class="header-anchor" href="#_3-1" aria-label="Permalink to &quot;3-1&quot;">​</a></h2><h3 id="mybatis-实现一对一有几种方式" tabindex="-1">MyBatis 实现一对一有几种方式? <a class="header-anchor" href="#mybatis-实现一对一有几种方式" aria-label="Permalink to &quot;MyBatis 实现一对一有几种方式?&quot;">​</a></h3><p>有联合查询和嵌套查询。</p><p><strong>联合查询</strong> 是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；</p><p><strong>嵌套查询</strong> 是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。</p>',70),o=[l];function s(h,n,d,u,c,b){return e(),i("div",null,o)}const m=a(r,[["render",s]]);export{p as __pageData,m as default};
