import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.5584abd2.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{"readingTime":false,"hidden":true},"headers":[],"relativePath":"question-by-day/2023/10.md","filePath":"question-by-day/2023/10.md","lastUpdated":1697195414000}'),o={name:"question-by-day/2023/10.md"},p=l(`<h2 id="_10-13" tabindex="-1">10-13 <a class="header-anchor" href="#_10-13" aria-label="Permalink to &quot;10-13&quot;">​</a></h2><h3 id="运行时异常与受检异常有何异同" tabindex="-1">运行时异常与受检异常有何异同？ <a class="header-anchor" href="#运行时异常与受检异常有何异同" aria-label="Permalink to &quot;运行时异常与受检异常有何异同？&quot;">​</a></h3><p>所有异常都继承自java.lang.Throwable，它有两个直接的子类Error与Exception。</p><p>Java Compiler 要求所有的 Exception 要么被 catch ，要么被 throw，除非这是一个 RuntimeExeption。</p><p>**受检异常（Checked Exception）**是在编译时期有编译器检测的异常，该异常必须要被处理。受检异常继承于Exception。</p><p>**非受检异常（Unchecked Exception）**是在运行时期的异常，即编译器不会检测异常，需要时也可以捕获异常。非受检异常继承于RuntimeException。</p><h2 id="_10-12" tabindex="-1">10-12 <a class="header-anchor" href="#_10-12" aria-label="Permalink to &quot;10-12&quot;">​</a></h2><h3 id="是否可以继承string类" tabindex="-1">是否可以继承String类？ <a class="header-anchor" href="#是否可以继承string类" aria-label="Permalink to &quot;是否可以继承String类？&quot;">​</a></h3><p>String 类是不能被继承的，因为他是被final关键字修饰的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">String</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> java.io.</span><span style="color:#B392F0;">Serializable</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">Comparable</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt;, </span><span style="color:#B392F0;">CharSequence</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">               </span><span style="color:#B392F0;">Constable</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">ConstantDesc</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  ......</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> java.io.</span><span style="color:#6F42C1;">Serializable</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">Comparable</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt;, </span><span style="color:#6F42C1;">CharSequence</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">               </span><span style="color:#6F42C1;">Constable</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">ConstantDesc</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  ......</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="_10-11" tabindex="-1">10-11 <a class="header-anchor" href="#_10-11" aria-label="Permalink to &quot;10-11&quot;">​</a></h2><h3 id="string-类的长度有限制吗" tabindex="-1">String 类的长度有限制吗？ <a class="header-anchor" href="#string-类的长度有限制吗" aria-label="Permalink to &quot;String 类的长度有限制吗？&quot;">​</a></h3><p>String 是由一个字符数组 <code>char[]</code> 来存储的，由于数组的长度及索引是整数且 String 类中返回字符串长度的方法 <code>length()</code> 的返回值也是 int ， 所以通过查看 java 源码中的类 Integer 我们可以看到 Integer 的最大范围是<code>2^31 -1</code>, 由于数组是从0开始的，所以数组的最大长度可以使【0~2^31】通过计算是大概4GB。</p><p>但是通过翻阅 java 虚拟机手册对 class 文件格式的定义以及常量池中对 String 类型的结构体定义我们可以知道对于索引定义了 u2，就是无符号占2个字节， 2个字节可以表示的最大范围是 <code>2^16 -1 = 65535</code>。 但是由于JVM需要1个字节表示结束指令，所以这个范围就为65534了。 超出这个范围在编译时期是会报错的，但是运行时拼接或者赋值的话范围是在整形的最大范围。</p><h2 id="_10-10" tabindex="-1">10-10 <a class="header-anchor" href="#_10-10" aria-label="Permalink to &quot;10-10&quot;">​</a></h2><h3 id="什么是节流和防抖-应用场景有哪些" tabindex="-1">什么是节流和防抖？应用场景有哪些？ <a class="header-anchor" href="#什么是节流和防抖-应用场景有哪些" aria-label="Permalink to &quot;什么是节流和防抖？应用场景有哪些？&quot;">​</a></h3><p>在前端开发过程中，当函数绑定到某些可能会持续触发的事件中时， 可能会造成性能和资源的浪费。如鼠标的移动、提交按钮可能被用户快速重复的点击等。 <strong>节流</strong>和<strong>防抖</strong>就是为了解决这一问题。</p><ul><li><strong>防抖（debounce）：</strong> 防抖指事件触发时，它将在指定时间后执行，如果这段时间内再次被调用，则重新计算执行时间。 通常用于滚动事件、调整窗口大小、鼠标移动、窗口搜索建议等。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">debounce</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">func</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">delay</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> timeoutId;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">clearTimeout</span><span style="color:#E1E4E8;">(timeoutId);</span></span>
<span class="line"><span style="color:#E1E4E8;">        timeoutId </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">func</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">args);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }, delay);</span></span>
<span class="line"><span style="color:#E1E4E8;">    };</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用防抖函数</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">debouncedFunction</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">debounce</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Debounced function called.&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 模拟事件触发</span></span>
<span class="line"><span style="color:#B392F0;">setInterval</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">debouncedFunction</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">200</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">// 防抖后，该函数触发后会等待1秒，如果1秒内再次触发，则重新计时</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">debounce</span><span style="color:#24292E;">(</span><span style="color:#E36209;">func</span><span style="color:#24292E;">, </span><span style="color:#E36209;">delay</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> timeoutId;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">...</span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">clearTimeout</span><span style="color:#24292E;">(timeoutId);</span></span>
<span class="line"><span style="color:#24292E;">        timeoutId </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">func</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">args);</span></span>
<span class="line"><span style="color:#24292E;">        }, delay);</span></span>
<span class="line"><span style="color:#24292E;">    };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用防抖函数</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">debouncedFunction</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">debounce</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Debounced function called.&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 模拟事件触发</span></span>
<span class="line"><span style="color:#6F42C1;">setInterval</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">debouncedFunction</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">200</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">// 防抖后，该函数触发后会等待1秒，如果1秒内再次触发，则重新计时</span></span></code></pre></div><ul><li><strong>节流（throttle）：</strong> 节流指连续触发多次的事件在指定时间范围内只执行一次，进而限制函数的执行频率。 通常用于自动保存、延时执行等。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">throttle</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">func</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">delay</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> lastCall </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">now</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Date</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getTime</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (now </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> lastCall </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> delay) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    lastCall </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> now;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">func</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">args);</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用节流函数</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">throttledFunction</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">throttle</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Throttled function called.&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 模拟事件触发</span></span>
<span class="line"><span style="color:#B392F0;">setInterval</span><span style="color:#E1E4E8;">(throttledFunction, </span><span style="color:#79B8FF;">200</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">// 节流后，该函数每秒最多执行一次</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">throttle</span><span style="color:#24292E;">(</span><span style="color:#E36209;">func</span><span style="color:#24292E;">, </span><span style="color:#E36209;">delay</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> lastCall </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">...</span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">now</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Date</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getTime</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (now </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> lastCall </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> delay) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    lastCall </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> now;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">func</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">args);</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用节流函数</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">throttledFunction</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">throttle</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Throttled function called.&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 模拟事件触发</span></span>
<span class="line"><span style="color:#6F42C1;">setInterval</span><span style="color:#24292E;">(throttledFunction, </span><span style="color:#005CC5;">200</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">// 节流后，该函数每秒最多执行一次</span></span></code></pre></div><blockquote><p>总的来说，节流和防抖都是为了限制函数执行的频率，以优化性能、减少不必要的计算或请求，提高用户体验。选择使用哪种取决于具体的需求和事件特性。</p></blockquote><h2 id="_10-9" tabindex="-1">10-9 <a class="header-anchor" href="#_10-9" aria-label="Permalink to &quot;10-9&quot;">​</a></h2><h3 id="请描述-static-修饰符。" tabindex="-1">请描述 static 修饰符。 <a class="header-anchor" href="#请描述-static-修饰符。" aria-label="Permalink to &quot;请描述 static 修饰符。&quot;">​</a></h3><p><code>static</code> 关键字可以用于类、方法、属性等。</p><p><strong>静态字段</strong></p><p>如果将一个字段定义为static，那么这个字段并不会出现在每个类的对象中。每个静态字段只有一个副本。可以认为静态字段属于类，而不属于单个对象。</p><p><strong>静态常量</strong></p><p>JAVA中没有用于修饰常量的关键字，所以常量的修饰通常使用 <code>public static final</code> 三个关键字共同修饰。使其静态加载且不允许修改。</p><p><strong>静态方法</strong></p><p>静态方法是不操作对象的方法。例如 <code>Math.pow(x,a)</code>会计算 x 的 a 次幂。它不会使用任何 Math 对象来完成该方法调用。它没有隐式参数。</p><p><strong>工厂方法</strong></p><p>类似于 <code>LocalDate</code> 和 <code>NumberFormat</code> 的类使用静态工厂方法来构造对象，就是静态方法：</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">LocalDate localdate </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> LocalDate.</span><span style="color:#B392F0;">now</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">LocalDate localdate </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> LocalDate.</span><span style="color:#B392F0;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2020</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">13</span><span style="color:#E1E4E8;">);  </span></span>
<span class="line"><span style="color:#E1E4E8;">System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(NumberFormat.</span><span style="color:#B392F0;">format</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0.1</span><span style="color:#E1E4E8;">));</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">LocalDate localdate </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> LocalDate.</span><span style="color:#6F42C1;">now</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">LocalDate localdate </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> LocalDate.</span><span style="color:#6F42C1;">of</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2020</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">13</span><span style="color:#24292E;">);  </span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(NumberFormat.</span><span style="color:#6F42C1;">format</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0.1</span><span style="color:#24292E;">));</span></span></code></pre></div><p><strong>main 方法</strong></p><p>调用静态方法不需要任何对象，与 <code>Math.pow</code> 同理，main 方法也是一个静态方法，启动程序时没有任何对象，将执行 main 方法并构造程序所需要的对象。</p><h2 id="_10-8" tabindex="-1">10-8 <a class="header-anchor" href="#_10-8" aria-label="Permalink to &quot;10-8&quot;">​</a></h2><h3 id="请描述修饰符、访问修饰符-非访问修饰符。" tabindex="-1">请描述修饰符、访问修饰符，非访问修饰符。 <a class="header-anchor" href="#请描述修饰符、访问修饰符-非访问修饰符。" aria-label="Permalink to &quot;请描述修饰符、访问修饰符，非访问修饰符。&quot;">​</a></h3><ul><li><p><strong>修饰符</strong>（Modifiers）：指用于修饰类、方法。变量等的关键字，用于置顶元素的访问类型。作用域、权限、继承性、抽象性等。修饰符分为访问修饰符和非访问修饰符。</p></li><li><p><strong>访问修饰符（Access Modifiers）</strong>: 访问修饰符控制类、方法、变量等的访问权限，共有以下四中：</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>public</td><td>能被任何类访问。</td></tr><tr><td>protected</td><td>同一包课件，其他包的子类可见。</td></tr><tr><td>default</td><td>默认，只能在同一包中被访问。</td></tr><tr><td>private</td><td>只能在同一类中访问。</td></tr></tbody></table></li><li><p><strong>非访问修饰符（Non-Access Modifiers）</strong>: 非访问修饰符用于实现其他功能，包括以下几种类型：</p></li></ul><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>final</td><td>表示不可继承的类、不可重写的方法或不可修改的变量。</td></tr><tr><td>abstract</td><td>表示抽象类或抽象方法，不能直接实例化抽象类。</td></tr><tr><td>static</td><td>静态资源关键字，用于创建类级别的变量或方法，而非实例级别。</td></tr><tr><td>synchronize</td><td>用于同步代码块，保证多线程环境下的同步访问。</td></tr><tr><td>transient</td><td>用于表示不需要序列化的变量。</td></tr><tr><td>volatile</td><td>用于表示多线程共享变量，保证可见性但不保证原子性。</td></tr><tr><td>strictfp</td><td>用于强制浮点运算遵循IEEE 764 标准，确保跨平台的浮点计算结果一致。</td></tr><tr><td>sealed</td><td>密封类。用于控制哪些类可以对该类进行拓展。</td></tr><tr><td>record</td><td>用于创建不可变的数据类。</td></tr></tbody></table><h2 id="_10-7" tabindex="-1">10-7 <a class="header-anchor" href="#_10-7" aria-label="Permalink to &quot;10-7&quot;">​</a></h2><h3 id="什么是方法签名" tabindex="-1">什么是方法签名？ <a class="header-anchor" href="#什么是方法签名" aria-label="Permalink to &quot;什么是方法签名？&quot;">​</a></h3><p>在上一篇中说到，重写必须要求方法签名相同，这里的<strong>方法签名</strong>（Method Signature），指的是方法名称及参数类型列表。如：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sum</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> a, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> b){</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> b;}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sum</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> a, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> b){</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> b;}</span></span></code></pre></div><p>该方法的方法签名为： <code>sum(int, int)</code></p><h2 id="_10-6" tabindex="-1">10-6 <a class="header-anchor" href="#_10-6" aria-label="Permalink to &quot;10-6&quot;">​</a></h2><h3 id="重载和重写是什么意思-有什么区别" tabindex="-1">重载和重写是什么意思？有什么区别？ <a class="header-anchor" href="#重载和重写是什么意思-有什么区别" aria-label="Permalink to &quot;重载和重写是什么意思？有什么区别？&quot;">​</a></h3><p><code>重载</code>（Overloading）指在同一个类中可以定义多个参数列表不同的同名方法，其互相的关系是重载。它是编译时多态（静态绑定），根据参数列表选择调用对应的方法。</p><p><code>重写</code>（Overriding）指子类可以重新定义父类中非私有的方法，方法签名必须相同。子类可以通过重写父类的方法来实现自己的特定行为。它是运行时多态（动态绑定），在运行时根据对象的实际类型选择调用对应的方法。</p><h2 id="_10-5" tabindex="-1">10-5 <a class="header-anchor" href="#_10-5" aria-label="Permalink to &quot;10-5&quot;">​</a></h2><h3 id="string、stringbuilder、stringbuffer-的区别及使用场景" tabindex="-1">String、StringBuilder、StringBuffer 的区别及使用场景 <a class="header-anchor" href="#string、stringbuilder、stringbuffer-的区别及使用场景" aria-label="Permalink to &quot;String、StringBuilder、StringBuffer 的区别及使用场景&quot;">​</a></h3><p><code>String</code> 由 final 关键字修饰，一旦定义就不可改变。可以在操作少量数据时使用。</p><p><code>StringBuilder</code> 可变，但是线程不安全。操作单线程大量数据时使用。</p><p><code>StringBuffer</code> 可变，线程安全。操作多线程大数据时使用。</p><h2 id="_10-4" tabindex="-1">10-4 <a class="header-anchor" href="#_10-4" aria-label="Permalink to &quot;10-4&quot;">​</a></h2><h3 id="请描述-instanceof-关键字" tabindex="-1">请描述 instanceof 关键字 <a class="header-anchor" href="#请描述-instanceof-关键字" aria-label="Permalink to &quot;请描述 instanceof 关键字&quot;">​</a></h3><p><code>instanceof</code> 是 JAVA 的一个二元操作符，类似于大于小于号，用于测试其左边的对象是否是它右边对象的实例，返回 Boolean 类型。在下方的 <a href="#_10-3">10-3</a> 的示例中，String 类的 equals 方法中使用了 <code>instanceof</code> 关键字对比较的对象进行实例检查，并转换为 String 类型。</p><h2 id="_10-3" tabindex="-1">10-3 <a class="header-anchor" href="#_10-3" aria-label="Permalink to &quot;10-3&quot;">​</a></h2><h3 id="与-equals-的区别" tabindex="-1"><code>==</code> 与 <code>equals</code> 的区别 <a class="header-anchor" href="#与-equals-的区别" aria-label="Permalink to &quot;\`==\` 与 \`equals\` 的区别&quot;">​</a></h3><p>两者的作用都是判断是否相等。但是 <code>==</code> 是运算符，<code>equals</code> 是继承于 Object 类的一个方法。</p><p>对于 <code>==</code> 来讲，如果比较<strong>基本数据类型</strong>，则比较其存储的值。如果比较<strong>引用数据类型</strong>，则比较其对象的地址值是否相等。</p><p>对于 <code>equals</code> 方法来讲，其本身并不提供<strong>基本数据类型</strong>的比较，但是可以使用 Objects 类提供的静态 equals 进行比较，如果是基本数据类型，其实现也是使用 <code>==</code>：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(Object a, Object b) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (a </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> b) </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> (a </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> a.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(b));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(Object a, Object b) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (a </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> b) </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (a </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> a.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(b));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>继承于 Object 类的 <code>equals</code> 方法也是使用 <code>==</code> 进行比较：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(Object obj) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> obj);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(Object obj) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">this</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> obj);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>所以要比较两个引用数据类型，必须重写其 equals 方法才能实现对于特定条件的比较，这里以常用的 String 类进行举例，其重写的 equals 方法如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(Object anObject) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 判断其地址值相同，直接返回 TRUE</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> anObject) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 类型检查，判断是否为 String 的实例，如果是，anObject 会被转化为 aString 表示的 String 类型</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (anObject </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> String aString)</span></span>
<span class="line"><span style="color:#E1E4E8;">        	</span><span style="color:#6A737D;">// 是否压缩（紧凑表示方式），如果压缩则检查其编码是否相同</span></span>
<span class="line"><span style="color:#E1E4E8;">        	</span><span style="color:#6A737D;">// 这里 aString 是规范的命名方式。。。</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">COMPACT_STRINGS </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.coder </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> aString.coder)</span></span>
<span class="line"><span style="color:#E1E4E8;">        	</span><span style="color:#6A737D;">// 遍历比较字符数组</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> StringLatin1.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(value, aString.value);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(Object anObject) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 判断其地址值相同，直接返回 TRUE</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">this</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> anObject) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 类型检查，判断是否为 String 的实例，如果是，anObject 会被转化为 aString 表示的 String 类型</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (anObject </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> String aString)</span></span>
<span class="line"><span style="color:#24292E;">        	</span><span style="color:#6A737D;">// 是否压缩（紧凑表示方式），如果压缩则检查其编码是否相同</span></span>
<span class="line"><span style="color:#24292E;">        	</span><span style="color:#6A737D;">// 这里 aString 是规范的命名方式。。。</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">COMPACT_STRINGS </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.coder </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> aString.coder)</span></span>
<span class="line"><span style="color:#24292E;">        	</span><span style="color:#6A737D;">// 遍历比较字符数组</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> StringLatin1.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(value, aString.value);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="_10-2" tabindex="-1">10-2 <a class="header-anchor" href="#_10-2" aria-label="Permalink to &quot;10-2&quot;">​</a></h2><h3 id="_3-0-1-0-3-将会返回什么-true-还是-false" tabindex="-1"><code>3 * 0.1 == 0.3</code> 将会返回什么? true 还是 false? <a class="header-anchor" href="#_3-0-1-0-3-将会返回什么-true-还是-false" aria-label="Permalink to &quot;\`3 * 0.1 == 0.3\` 将会返回什么? true 还是 false?&quot;">​</a></h3><p><strong>答案：</strong><code>FALSE</code></p><p>这道题跟 <code>01+0.2 != 0.3</code> 是一样的，由于在计算机系统中使用二进制浮点数无法精确的表示诸如 <code>10/3</code> 等无限循环的十进制分数的值，Java中的<code>double</code>和<code>float</code>类型使用IEEE 754标准来表示浮点数，这种表示方式会导致一些十进制分数无法精确地表示。因此，当你尝试在Java中表示0.3时，可能会得到一个非常接近 0.3 的值，但不会是精确的 0.3。</p><p>要想精确的表示十进制小数，可以使用 <code>BigDecimal</code> 类进行精确的十进制数学运算，但是会更为复杂并造成额外的开销。</p><h2 id="_10-1" tabindex="-1">10-1 <a class="header-anchor" href="#_10-1" aria-label="Permalink to &quot;10-1&quot;">​</a></h2><h3 id="请详述-jdk-jre-jvm-等的关系" tabindex="-1">请详述 <code>JDK</code> <code>JRE</code> <code>JVM</code> 等的关系 <a class="header-anchor" href="#请详述-jdk-jre-jvm-等的关系" aria-label="Permalink to &quot;请详述 \`JDK\` \`JRE\` \`JVM\` 等的关系&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">声明</p><p>该内容由 <code>CHATGPT</code> 生成</p></div><ol><li><p><strong><code>JDK</code>（Java Development Kit）</strong>：</p><p><code>JDK</code> 是Java开发工具包，它是Java开发人员用来编写、编译、调试和运行Java程序的核心工具。JDK包括了Java编译器（javac）、Java解释器（java）、Java文档生成器（javadoc）等工具，以及Java开发所需的库和资源文件。</p></li><li><p><strong><code>JRE</code>（Java Runtime Environment）</strong>：</p><p>JRE是Java运行时环境，是Java程序的运行环境，用于执行已经编译好的Java字节码。<code>JRE</code>包括了Java虚拟机（<code>JVM</code>）、Java类库（Java API）和运行时所需的其他组件。JRE提供了在特定平台上运行Java程序所需的基本功能。</p></li><li><p><strong><code>JVM</code>（Java Virtual Machine）</strong>：</p><p><code>JVM</code> 是Java虚拟机，是Java程序的运行引擎，负责将Java字节码解释或编译成特定平台的本地机器代码，并执行程序。<code>JVM</code> 是 <code>JRE</code> 的一部分，它是一个虚拟的计算机，可以在不同的硬件和操作系统上运行Java程序。</p></li></ol><p><strong>关系总结</strong>：</p><ul><li>JDK包括JRE，JRE包括JVM。</li><li>JDK提供了开发、编译、调试等工具，以及JRE所需的库和资源。</li><li>JRE提供了JVM和Java API，用于运行Java程序。</li><li>JVM是Java程序的运行引擎，它执行Java字节码并负责内存管理、垃圾回收等。</li><li>Java程序首先由JDK编译生成Java字节码，然后JRE中的JVM解释或编译Java字节码并执行。</li></ul>`,78),e=[p];function t(c,r,E,y,i,d){return a(),n("div",null,e)}const F=s(o,[["render",t]]);export{h as __pageData,F as default};
