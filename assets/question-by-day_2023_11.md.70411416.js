import{_ as e,o as t,c as a,Q as r}from"./chunks/framework.ccb7d467.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{"readingTime":false,"hidden":true},"headers":[],"relativePath":"question-by-day/2023/11.md","filePath":"question-by-day/2023/11.md","lastUpdated":1699092538000}'),o={name:"question-by-day/2023/11.md"},n=r('<h2 id="_11-4" tabindex="-1">11-4 <a class="header-anchor" href="#_11-4" aria-label="Permalink to &quot;11-4&quot;">​</a></h2><h3 id="execute-与-submit-的用法与区别。" tabindex="-1">execute 与 submit 的用法与区别。 <a class="header-anchor" href="#execute-与-submit-的用法与区别。" aria-label="Permalink to &quot;execute 与 submit 的用法与区别。&quot;">​</a></h3><p>execute 执行后<strong>没有返回结果</strong>，只有1种用法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void execute(Runnable command)</code></td><td>常规使用方法，用没有返回值的 execute 执行没有返回值的 Runnable 任务</td></tr></tbody></table><p>submit 执行后<strong>有返回结果</strong>，有3种用法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Future submit(Callable task)</code></td><td>常规使用方法，传入有返回值的 callable 任务，最终返回 task 的返回值</td></tr><tr><td><code>Future submit(Runnable task, T result)</code></td><td>由于 Runnable 没有返回值，但是可以自定义一个返回值用于返回</td></tr><tr><td><code>Future submit(Runnable task)</code></td><td>强行使用 submit 执行 Runnable 方法，忽略返回值</td></tr></tbody></table><h2 id="_11-3" tabindex="-1">11-3 <a class="header-anchor" href="#_11-3" aria-label="Permalink to &quot;11-3&quot;">​</a></h2><h3 id="runnable-与-callable-的区别。" tabindex="-1">Runnable 与 Callable 的区别。 <a class="header-anchor" href="#runnable-与-callable-的区别。" aria-label="Permalink to &quot;Runnable 与 Callable 的区别。&quot;">​</a></h3><p>Runnable 没有返回结果，即没有 return 语句；Callable 有返回结果。</p><p>可以通过 Executors 工厂类将 Runnable 封装为一个 Callable 对象。</p><h2 id="_11-2" tabindex="-1">11-2 <a class="header-anchor" href="#_11-2" aria-label="Permalink to &quot;11-2&quot;">​</a></h2><h3 id="请描述-executor-框架的执行过程。" tabindex="-1">请描述 Executor 框架的执行过程。 <a class="header-anchor" href="#请描述-executor-框架的执行过程。" aria-label="Permalink to &quot;请描述 Executor 框架的执行过程。&quot;">​</a></h3><p>1、通过实现 Runnable 接口或 Callable 接口创建任务。</p><p>2、通过Executors的工厂方法创建线程池。</p><p>3、通过 <code>ExecutorService.submit()</code> 提交一个有返回结果的任务，返回类型为一个实现Future接口的对象；或通过ExecutorService.execute()方法执行一个没有返回结果的任务。</p><p>4、通过 <code>FutureTask.get()</code> 获取返回结果（如果有）。</p><h2 id="_11-1" tabindex="-1">11-1 <a class="header-anchor" href="#_11-1" aria-label="Permalink to &quot;11-1&quot;">​</a></h2><h3 id="说一说你理解的-executor-框架。" tabindex="-1">说一说你理解的 Executor 框架。 <a class="header-anchor" href="#说一说你理解的-executor-框架。" aria-label="Permalink to &quot;说一说你理解的 Executor 框架。&quot;">​</a></h3><p>Executor 是线程池的调度工具，线程池是 Executor 的一部分。</p><p>Executor 框架由三大部分组成</p><p>1、<strong>任务</strong>：即被执行任务需要实现的接口：<strong>Runnable</strong> 接口或 <strong>Callable</strong> 接口。</p><p>2、<strong>线程池</strong>：主要通过 <strong>ExecutorService</strong> 接口调用线程池，有2个关键实现类 <strong>ThreadPoolExecutor</strong> 和 * <em>ScheduledThreadPoolExecutor</em>*。</p><p>3、<strong>异步计算的结果</strong>：<strong>Future</strong> 接口及其实现类 <strong>FutureTask</strong>。</p>',23),l=[n];function u(d,s,c,i,h,b){return t(),a("div",null,l)}const _=e(o,[["render",u]]);export{x as __pageData,_ as default};
